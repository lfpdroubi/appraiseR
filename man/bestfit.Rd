% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bestfit.R
\name{bestfit}
\alias{bestfit}
\title{Best fit models}
\usage{
bestfit(formula, data, subset, transf = c("rsqrt", "log", "sqrt"))
}
\arguments{
\item{formula}{A standard linear regression formula, with no transformation
in the parameters.}

\item{data}{A data frame containing the variables in the model.}

\item{subset}{a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector (see \link{[.data.frame}) for the
rows of data or if that is not supplied, a data frame made up of the
variables used in \code{formula}.}

\item{transf}{A family of functions to be used to transform the variables in
the data frame, in order to find the best combination of transformation to
be applied to the data - usually functions of the box-cox family.}
}
\description{
Find best transformations of the parameters for Linear Regression.
}
\examples{
dados <- st_drop_geometry(centro_2015)
best_fit <- bestfit(valor ~ ., data = dados)
print(best_fit, n = 20)
s <- summary(best_fit)

#There still may be outliers:
out <- car::outlierTest(s$fit)
outliers <- match(names(out$p), rownames(dados))

# There are two ways to handle with them:

# Recalling bestfit with a subset argument ...
best_fit <- bestfit(valor ~ ., data = dados, subset = -outliers)

# Or assigning a subset argument directly into summary.bestfit
 s <- summary(best_fit, fit = 1, subset = -outliers)

# The latter takes less computational effort, since it only updates the
# lm call of the chosen fit. The former is more precise, since it runs
# bestfit again without the outliers.

}
