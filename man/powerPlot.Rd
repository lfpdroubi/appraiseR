% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/powerPlot.R
\name{powerPlot}
\alias{powerPlot}
\alias{powerPlot.default}
\alias{powerPlot.lm}
\alias{powerPlot.bestfit}
\alias{powerPlot.lmerMod}
\alias{powerPlot.rq}
\title{Power plots with ggplot2}
\usage{
powerPlot(y, yhat, ...)

\method{powerPlot}{default}(
  y,
  yhat,
  axis = c("standard", "inverted"),
  smooth = TRUE,
  se = FALSE,
  metrics = c("rmse", "mae"),
  R2 = TRUE,
  ...
)

\method{powerPlot}{lm}(object, func, ...)

\method{powerPlot}{bestfit}(object, fit = 1, scale = c("transformed", "original"), ...)

\method{powerPlot}{lmerMod}(object, func, ...)

\method{powerPlot}{rq}(object, func, ...)
}
\arguments{
\item{y}{observed values}

\item{yhat}{predicted values}

\item{\dots}{further args passed to powerPlot.default}

\item{axis}{option to plot predicted values on the x axis (inverted) or in
the y axis (standard)}

\item{smooth}{option to add a regression line to the plot}

\item{se}{option to add confidence interval of regression line to the plot}

\item{metrics}{TRUE or FALSE. If TRUE, metrics (RMSE, MAE and MAPE) are
displayed at the plot area.}

\item{R2}{TRUE or FALSE. If TRUE, R2 between predicted and observed values
are printed.}

\item{object}{object of class \code{\link{lm}}, \code{\link{rq}},
\code{\link{lmerMod}} or \code{\link{bestfit}}.}

\item{func}{function used to transform the dependent variable (the inverse
of this function will be used to retransform the data to the original scale).}

\item{fit}{chosen fit}

\item{scale}{Plot values in original or transformed scale?}
}
\value{
a power plot
}
\description{
\code{powerPlot} generates Power Plots for \code{\link{lm}} or
\code{\link{bestfit}} objects with \code{\link{ggplot2}}.
}
\examples{
library(sf)
dados <- st_drop_geometry(centro_2015)
dados$padrao <- as.numeric(dados$padrao)
fit <- lm(log(valor) ~ area_total + quartos + suites + garagens +
log(dist_b_mar) + I(1/padrao), dados, subset = -c(31, 39))
s <- summary(fit)
# Mediana
library(ggplot2)
p <- powerPlot(fit, scale = "original", func = "log", axis = "inverted", )
p + labs(title = "Poder de Predição", subtitle = "Mediana")
# Média
y <- na.omit(dados$valor)[-c(31, 39)]
yhat <- exp(fitted(fit) + s$sigma^2/2)
p1 <- powerPlot(y = y, yhat = yhat , axis = "inverted")
p1 + labs(title = "Poder de Predição", subtitle = "Média")
# Moda
p2 <- powerPlot(y = na.omit(dados$valor)[-c(31, 39)],
                yhat = exp(fitted(fit) - s$sigma^2), axis = "inverted")
p2 + labs(title = "Poder de Predição", subtitle = "Moda")
fit <- lm(I(valor^(1/3)) ~ area_total + quartos + suites + garagens +
log(dist_b_mar) + I(1/padrao), dados, subset = -c(31, 39, 42))
s <- summary(fit)
powerPlot(y = na.omit(dados$valor)[-c(31, 39, 42)],
          yhat = fitted(fit)^3 + 3*fitted(fit)*s$sigma^2,
          metrics = FALSE
)
powerPlot(fit)
powerPlot(fit, se = TRUE)
powerPlot(fit, smooth = FALSE)
powerPlot(fit, axis = "inverted")
p <- powerPlot(fit, func = "log", axis = "inverted")
p + labs(title = "Poder de Predição", subtitle = "Em milhões de Reais")
# Changes Dep Var Transformation
fit <- lm(sqrt(valor) ~ area_total + quartos + suites + garagens +
log(dist_b_mar) + I(1/padrao), dados)
powerPlot(fit)
powerPlot(fit, func = "sqrt", axis = "inverted")
dados <- st_drop_geometry(centro_2015)
dados <- within(dados, padrao <- as.numeric(padrao))
best_fit <- bestfit(valor ~ ., dados,
                    transf = c("rec", "rsqrt", "log", "sqrt"),
                    subset = -c(31, 39))
p1 <- powerPlot(best_fit)
p2 <- powerPlot(best_fit, scale = "original")
cowplot::plot_grid(p1, p2, nrow = 1, ncol = 2)
p1 <- powerPlot(best_fit, axis = "inverted")
p2 <- powerPlot(best_fit, axis = "inverted", scale = "original")
cowplot::plot_grid(p1, p2, nrow = 1, ncol = 2)
powerPlot(best_fit, fit = 514)
p1 <- powerPlot(best_fit, fit = 514, axis = "inverted")
p2 <- powerPlot(best_fit, fit = 514, scale = "original", axis = "inverted")
cowplot::plot_grid(p1, p2, nrow = 1, ncol = 2)

library(lme4)
Mfit <- lmer(log(valor) ~ area_total + quartos + suites + garagens +
dist_b_mar + (1|padrao), dados)
powerPlot(Mfit)
powerPlot(Mfit, func = "log")
library(quantreg)
set.seed(1)
dados <- data.frame(
Area = runif(100, min = 360, max = 600)
)
dados$LVU <- 12 - .0075*dados$Area + rnorm(100, mean = 0, sd = .25)
dados$VU <- exp(dados$LVU)
medFit <- rq(VU~Area, data = dados)
powerPlot(medFit)
powerPlot(medFit, axis = "inverted")
}
